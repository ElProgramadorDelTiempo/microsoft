
Inferencia de tipo en TypeScript
let x: number;   //* Declara explícitamente x como un número
let y = 1;       //* Declara implícitamente y como un número (inferencia de tipos)
let z;           //* Declara z sin inicializarlo, por lo que el tipo es 'any' por defecto

> **Comentario:** La inferencia de tipos es una de las características más potentes de TypeScript. Siempre que sea posible, se recomienda permitir que el compilador infiera los tipos, ya que mejora la legibilidad del código y reduce la redundancia.

Tipos primitivos en TypeScript

Tipo booleano
let flag: boolean;
let yes = true;   //* Inferido como boolean
let no = false;   //* Inferido como boolean

Tipos numéricos y BigInteger
let x: number;
let y = 0;                 //* Inferido como número
let z: number = 123.456;    //* Declaración explícita de tipo
let big: bigint = 100n;     //* 'bigint' para enteros de precisión arbitraria

> **Comentario:** bigint es útil cuando se necesita manejar números más allá del rango de number en JavaScript, que se limita a 2^53 - 1.

Tipo de cadena
let s: string;
let empty = "";     //* Inferido como cadena vacía
let abc = 'abc';    //* Inferido como cadena

Expresiones insertadas (template literals)
let firstName: string = "Mateo";
let sentence: string = `My name is ${firstName}.
    I am new to TypeScript.`;
console.log(sentence);  //* Muestra el mensaje con interpolación de variables

> **Comentario:** Los template literals no solo mejoran la legibilidad de las cadenas de texto, sino que también permiten fácilmente interpolar expresiones complejas.

El tipo de enumeración
enum ContractStatus {
     Permanent,    //* Asigna valores secuenciales automáticamente, comenzando en 0
     Temp,
     Apprentice
}

enum ContractStatus {
     Permanent = 1,   //* Asigna valores a partir de 1
     Temp,
     Apprentice
}

> **Comentario:** enum es útil cuando se trabaja con valores constantes y legibles. El valor por defecto es 0, pero se puede sobrescribir.

Tipos any y unknown en TypeScript

Tipo any
let randomValue: any = 10;
randomValue = 'Mateo';   //* OK
randomValue = true;      //* OK

Tipo unknown
let randomValue: unknown = 10;
randomValue = true;
randomValue = 'Mateo';

// console.log(randomValue.name);  //* Error: Object is of type 'unknown'
// randomValue();                  //* Error: Object is of type 'unknown'
// randomValue.toUpperCase();      //* Error: Object is of type 'unknown'

> **Comentario:** Aunque any es flexible, se debe evitar su uso cuando sea posible, ya que desactiva el sistema de tipos de TypeScript y puede llevar a errores inesperados.

Diferencia clave entre any y unknown:
- any: Omite todas las comprobaciones de tipo.
- unknown: Requiere comprobaciones antes de interactuar con el valor, mejorando la seguridad del código.

Aserciones de tipos
let randomValue: unknown = 'Mateo';

if (typeof randomValue === "string") {
    console.log((randomValue as string).toUpperCase());    //* Devuelve 'MATEO'
} else {
    console.log("Error - Se esperaba una cadena.");        //* Maneja el error
}

> **Comentario:** Las aserciones de tipo (as) son útiles cuando estás seguro del tipo de una variable en un contexto específico. Sin embargo, usa esta característica con precaución, ya que puede derivar en errores en tiempo de ejecución si el tipo asumido es incorrecto.

Tipos de unión e intersección

Tipos de unión
let multiType: number | boolean;
multiType = 20;       //* Válido
multiType = true;     //* Válido
multiType = "twenty"; //* Inválido

> **Comentario:** Los tipos de unión permiten que una variable sea de múltiples tipos, lo que da flexibilidad, pero aún mantiene el control de tipos.

Tipos de intersección
interface Employee {
  employeeID: number;
  age: number;
}

interface Manager {
  stockPlan: boolean;
}

type ManagementEmployee = Employee & Manager;

let newManager: ManagementEmployee = {
    employeeID: 12345,
    age: 34,
    stockPlan: true
};

> **Comentario:** Los tipos de intersección combinan múltiples tipos en uno solo, lo que es útil para representar objetos que tienen propiedades de varios tipos.

Tipos literales

Definición de tipos literales
type testResult = "pass" | "fail" | "incomplete";
let myResult: testResult;
myResult = "incomplete";    //* Válido
myResult = "pass";          //* Válido
myResult = "failure";       //* Inválido

Tipos literales numéricos
type dice = 1 | 2 | 3 | 4 | 5 | 6;
let diceRoll: dice;
diceRoll = 1;    //* Válido
diceRoll = 2;    //* Válido
diceRoll = 7;    //* Inválido

> **Comentario:** Los tipos literales restringen los valores posibles de una variable a un conjunto finito, lo que puede ser muy útil en escenarios de validación o estados predefinidos.

Tipos de colección en TypeScript

Matrices
let list: number[] = [1, 2, 3];
let list: Array<number> = [1, 2, 3];    //* Equivalente

> **Comentario:** Ambas sintaxis para declarar arrays ([] y Array<type>) son equivalentes. Se trata más de una cuestión de preferencia de estilo.

Tuplas
let person1: [string, number] = ['Marcia', 35];   //* Válido
let person1: [string, number] = ['Marcia', 35, true]; //* Error, demasiados elementos
let person1: [string, number] = [35, 'Marcia'];   //* Error, orden incorrecto

> **Comentario:** Las tuplas permiten especificar un número fijo de elementos con tipos definidos, lo que es útil cuando se necesita trabajar con estructuras de datos heterogéneas y de longitud fija.